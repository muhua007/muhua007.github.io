{"meta":{"title":"muhua的个人博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2020-10-05T21:47:22.000Z","updated":"2020-10-05T13:48:53.516Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-05T21:45:07.000Z","updated":"2020-10-05T13:48:43.124Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java字符串编码转换","slug":"java字符串编码转换","date":"2020-11-04T20:34:00.000Z","updated":"2020-11-04T12:35:21.328Z","comments":true,"path":"2020/11/05/java字符串编码转换/","link":"","permalink":"http://example.com/2020/11/05/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/","excerpt":"1234//将字符串按UTF-8编码转换为字节数组byte[] byte_s = &quot;中&quot;.getBytes(&quot;UTF-8&quot;);//将字节数组以ISO8859-1的编码方式转换为字符串String s_iso88591 = new String(byte_s,&quot;ISO8859-1&quot;);","text":"1234//将字符串按UTF-8编码转换为字节数组byte[] byte_s = &quot;中&quot;.getBytes(&quot;UTF-8&quot;);//将字节数组以ISO8859-1的编码方式转换为字符串String s_iso88591 = new String(byte_s,&quot;ISO8859-1&quot;); 12345678910111213public class Demo1 &#123; public static void main(String[] args) &#123; try &#123; // \\u 代表unicode编码，是一个字符； String s1 = &quot;\\u0021&quot;; System.out.println(s1); //结果为 ！ &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 1234567public class Demo1 &#123; public static void main(String[] args) &#123; //0x开头代表十六进制，实际上就是一个整数； int i1 = 0x001f; System.out.println(i1); //结果为 31 &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"为什么要重写hashcode方法","slug":"为什么要重写hashcode方法","date":"2020-11-04T20:15:50.000Z","updated":"2020-11-04T12:34:22.153Z","comments":true,"path":"2020/11/05/为什么要重写hashcode方法/","link":"","permalink":"http://example.com/2020/11/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/","excerpt":"hashcode方法Object中的hashcode是一个本地方法 其方法说明原文如下：","text":"hashcode方法Object中的hashcode是一个本地方法 其方法说明原文如下： 12345678910111213141516171819202122232425262728293031323334/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined * by class &#123;@code Object&#125; does return distinct integers for * distinct objects. (The hashCode may or may not be implemented * as some function of an object&#x27;s memory address at some point * in time.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ 汉语翻译12345678910111213141516/** * 返回该对象的哈希值。支持此方法是为了使hashMap提供的哈希表受益。 * 该方法的总协定是: * 1、每当在Java应用程序的执行期间对同一对象多次调用时，hashCode方法必须始终返回相同的整数，前提是没有修改对象上equals方法比较中使用的信 * 息。从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。 * 2、如果两个对象根据equals方法是相等的，那么对这两个对象中的每一个调用hashCode方法必须产生相同的整数结果。 * 3、如果两个对象根据equals方法是不相等的，那么在这两个对象上调用hashCode方法不必产生不同的整数结果。然而，程序员应该知道， * 为不相等的对象生成不同的整数结果可以提高hash tables的性能 * * 在合理可行的情况下，类Object定义的hashCode方法确实为不同的对象返回不同的整数。（在某个时间点，哈希码可以实现为对象内存 * 地址的某个函数，也可以不实现） * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ equal方法其方法说明原文如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Indicates whether some other object is &quot;equal to&quot; this one. * &lt;p&gt; * The &#123;@code equals&#125; method implements an equivalence relation * on non-null object references: * &lt;ul&gt; * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value * &#123;@code x&#125;, &#123;@code x.equals(x)&#125; should return * &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, &#123;@code x.equals(y)&#125; * should return &#123;@code true&#125; if and only if * &#123;@code y.equals(x)&#125; returns &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125;, &#123;@code y&#125;, and &#123;@code z&#125;, if * &#123;@code x.equals(y)&#125; returns &#123;@code true&#125; and * &#123;@code y.equals(z)&#125; returns &#123;@code true&#125;, then * &#123;@code x.equals(z)&#125; should return &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, multiple invocations of * &#123;@code x.equals(y)&#125; consistently return &#123;@code true&#125; * or consistently return &#123;@code false&#125;, provided no * information used in &#123;@code equals&#125; comparisons on the * objects is modified. * &lt;li&gt;For any non-null reference value &#123;@code x&#125;, * &#123;@code x.equals(null)&#125; should return &#123;@code false&#125;. * &lt;/ul&gt; * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */ 汉语翻译123456789101112131415161718/** * 指示某个其他对象是否“等于”此对象. * equals方法在非空对象引用上实现等价关系： * &lt;ul&gt; * 1、它是自反的：对于任何非空的引用值x，x.equals（x）应该返回true * 2、它是对称的：对于任何非空的引用值x和y，x.equals（y）应该返回true，当且仅当 y.equals（x）返回true * 3、它是可传递的：对于任何非空的引用值 x、 y和 z，如果 x.equals（y）返回 true和 y.equals（z）返回 true，那么 * x.equals（z）应该返回 true * 4、它是一致的：对于任何非空的引用值x和y，多次调用x.equals（y）一致返回true或一致返回false，前提是对象的equals比较中 * 没有使用被修改的信息 * 5、对于任何非空的引用值x，x.equals(null) 应该返回null * * 请注意，每当重写hashCode方法时，通常都需要重写hashCode方法，以便维护hashCode方法的一般约定，即相同的对象必须具有相同 * 的哈希代码。 * * @param obj the reference object with which to compare. * @return true if this object is the same as the obj * argument; false otherwise. * @see #hashCode() * @see java.util.HashMap */ 结论由上面hashcode与equal方法的说明可以知道： 1、equal判断相等时，hashcode返回的值不一定不相等。也就是所hashcode相等时，无法得知equal是否相等 2、equal判断相等时，hashcode返回值一定相等 由于当一个对象中有大量成员信息时，用equal比较效率会比较低。 故，在判断两对象是否相等时，可以先进行hashcode的判断，如果不相等，则一定不相等，若hashcode值相等，在通过equal方法判断。 扩展：关于HashSetHashSet集合特点：无序，元素唯一。 在HashSet集合中，通过hashcode和equal方法，保证元素的唯一性。","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"第一篇文章-用于测试","slug":"第一篇文章-用于测试","date":"2020-10-06T18:56:50.000Z","updated":"2020-10-06T10:56:50.266Z","comments":true,"path":"2020/10/07/第一篇文章-用于测试/","link":"","permalink":"http://example.com/2020/10/07/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0-%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库课堂作业","slug":"数据库课堂作业","date":"2020-10-06T18:56:50.000Z","updated":"2020-11-04T12:10:08.790Z","comments":true,"path":"2020/10/07/数据库课堂作业/","link":"","permalink":"http://example.com/2020/10/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E4%BD%9C%E4%B8%9A/","excerpt":"查询身高大于180厘米的男生的学号和姓名；","text":"查询身高大于180厘米的男生的学号和姓名； 123select Sno,Snamefrom Swhere Height&gt;180 查询计算机系（CS）所开设课程的课程号及选该课程的学生学号； 123select First.Cno,Second.Snofrom C First,SC Secondwhere First.Cno = Second.Cno and First.Sdept = &#x27;CS&#x27; 查询至少选修了一门电机系(EM)课程的女生的姓名； 123456789101112select Snamefrom Swhere Sex=&#x27;女&#x27; and Sno in ( select Sno from SC where Cno=( select Cno from C where Sdept = &#x27;EM&#x27; )) 查询SC表中每位学生已选课程的门数及其学号； 123select Sno,COUNT(Cno)from SCgroup by Sno 查询SC表中每位学生的平均成绩及其学号； 123select Sno,AVG(G)from SCgroup by Sno 查询SC表中每门课程选课的学生人数、最高成绩、最低成绩、平均成绩和课程号； 123select COUNT(Sno),MAX(G),MIN(G),AVG(G),Cnofrom SCgroup by Cno 查询所有课程的成绩都在80分以上的学生姓名、学号，并按学号升序排列； 12345select First.Sno,First.Snamefrom S First,SC Secondwhere First.Sno = Second.Snogroup by First.Sno having MIN(Second.G)&gt;80order by First.Sno ASC 查询缺成绩的学生的姓名及该门课程名。 12345select S.Sname,C.Cnofrom SC inner join C on SC.Cno = C.Cnoinner join S on S.Sno = SC.Snowhere SC.G is null","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-05T02:45:46.777Z","updated":"2020-10-06T12:49:03.957Z","comments":true,"path":"2020/10/05/hello-world/","link":"","permalink":"http://example.com/2020/10/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}